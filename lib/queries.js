// Generated by CoffeeScript 2.7.0
(function() {
  var _, anyFrequency, anyRace, anyRank, async, errorHandler, fastSimpleQuery, frequencyQuery, genderQuery, isNumber, isUndefined, limitQuery, properCase, raceQuery, rankQuery, sanitizeGender, sanitizeYear, startsWithQuery, yearQuery;

  async = require("async");

  _ = require('lodash');

  errorHandler = require('../lib/errorHandler');

  fastSimpleQuery = function(context, knex) {
    return context.where(knex.raw("id in (select (random()*(select last_value from surnames_id_seq))::bigint from generate_series(1,120))"));
  };

  frequencyQuery = function(context, freq, errorHandler) {
    if (freq === "low") {
      return context.where("frequency", "<", 0.06);
    } else if (freq === "medium") {
      return context.where("frequency", ">=", 0.06).andWhere("frequency", "<", 1);
    } else if (freq === "high") {
      return context.where("frequency", ">=", 1);
    } else if (freq === "any") {
      return anyFrequency(context);
    } else {
      if (!_.isUndefined(freq)) {
        errorHandler.addError(errorHandler.errorCodes['invalid_frequency']);
      }
      return anyFrequency(context);
    }
  };

  anyFrequency = function(context) {
    return context.where("frequency", ">", -1);
  };

  raceQuery = function(context, raceArray, errorHandler) {
    if (!_.isUndefined(raceArray)) {
      if (_.isString(raceArray[0]) && _.parseInt(raceArray[1])) {
        if (_.includes(["pctwhite", "pctasian", "pctnative", "pctblack", "pcthispanic", "any"], raceArray[0])) {
          if (raceArray[1] > 99 || raceArray[1] < 1) {
            return errorHandler.addError(errorHandler.errorCodes['invalid_race_pct']);
          } else if (raceArray[0] === "any") {
            return anyRace(context);
          } else {
            return context.where(raceArray[0], ">", Math.abs(_.parseInt(raceArray[1])));
          }
        } else {
          errorHandler.addError(errorHandler.errorCodes['invalid_race']);
          return anyRace(context);
        }
      } else {
        errorHandler.addError(errorHandler.errorCodes['invalid_race_pct']);
        return anyRace(context);
      }
    } else {
      return anyRace(context);
    }
  };

  anyRace = function(context) {
    return context.where("pctwhite", ">", -1);
  };

  limitQuery = function(limit, errorHandler) {
    if ((limit <= 100) && (limit >= 1)) {
      return limit;
    } else {
      if (!_.isUndefined(limit)) {
        console.log('limit is defined but not right');
        console.log(limit);
        errorHandler.addError(errorHandler.errorCodes['invalid_limit']);
      }
      return 10;
    }
  };

  yearQuery = function(context, req_year, errorHandler) {
    var year;
    year = sanitizeYear(req_year, errorHandler);
    return context.where({
      year: year
    });
  };

  sanitizeYear = function(rawYear, errorHandler) {
    var validYears;
    validYears = _.range(1880, 2013);
    validYears.push(0);
    if (validYears.indexOf(parseInt(rawYear)) > -1) {
      return parseInt(rawYear);
    } else if (_.isUndefined(rawYear)) {
      return 0;
    } else {
      errorHandler.addError(errorHandler.errorCodes['invalid_year']);
      return 0;
    }
  };

  genderQuery = function(context, req_gender, errorHandler) {
    var gender;
    gender = sanitizeGender(req_gender);
    if (gender) {
      return context.where({
        gender: gender
      });
    } else {
      if (!_.isUndefined(req_gender) && req_gender !== "any") {
        errorHandler.addError(errorHandler.errorCodes['invalid_gender']);
      }
      return context.where('gender', 'LIKE', '%');
    }
  };

  sanitizeGender = function(rawGender) {
    var gender, validGenders;
    validGenders = ['male', 'female'];
    if (validGenders.indexOf(rawGender > -1)) {
      gender = {
        'male': 'M',
        'female': 'F'
      };
      return gender[rawGender];
    } else {
      return false;
    }
  };

  rankQuery = function(context, req_rank, maxRank, errorHandler) {
    if (_.isString(req_rank) && !_.isUndefined(maxRank)) {
      if (maxRank > 5000) {
        if (req_rank === "low") {
          return context.where("rank", ">", 800);
        } else if (req_rank === "high") {
          return context.where("rank", "<=", 800);
        } else if (req_rank === "any") {
          return anyRank(context);
        }
      } else if (maxRank > 500) {
        if (req_rank === "low") {
          return context.where("rank", ">", 300);
        } else if (req_rank === "high") {
          return context.where("rank", "<=", 300);
        } else if (req_rank === "any") {
          return anyRank(context);
        } else {
          errorHandler.addError(errorHandler.errorCodes['invalid_rank']);
          return anyRank(context);
        }
      } else if (maxRank < 500) {
        if (req_rank === "low") {
          return context.where("rank", ">", 125);
        } else if (req_rank === 'high') {
          return context.where("rank", "<=", 125);
        } else if (req_rank === "any") {
          return anyRank(context);
        } else {
          errorHandler.addError(errorHandler.errorCodes['invalid_rank']);
          return anyRank(context);
        }
      }
    } else {
      return anyRank(context);
    }
  };

  startsWithQuery = function(context, req_letter, errorHandler) {
    var match, matches, pass;
    if (req_letter) {
      if (!req_letter.match(/[^a-zA-Z\-]/)) {
        return context.where("name", "LIKE", properCase(req_letter) + "%");
      // console.log "postProper: " + properCase(req_letter)

      // Look for * characters
      } else if (req_letter.match(/,*([a-zA-Z]+)\*/g)) {
        matches = req_letter.match(/,*([a-zA-Z]+)\*/g);
        pass = context;
        // Cycle through the matches adding NOT LIKE where statements
        _.each(matches, function(match) {
          return pass = context.where("name", "NOT LIKE", properCase(match.replace(',', '').replace('*', '')) + "%");
        });
        // Need to figure out how to do multiple where statements based on number of matches
        // Maybe limit it to three exclusions and change NOT LIKE to LIKE and leave "%" by itself
        // Or maybe this is a job for some sort of pass variable that holds the context and then adds more through while
        return pass;
      } else if (req_letter.match(/([a-zA-Z]+)\^/)) {
        match = properCase(req_letter.match(/([a-zA-Z]+)\^/)[0]).replace('^', '');
        return context.where("name", match);
      } else {
        errorHandler.addError(errorHandler.errorCodes['invalid_startswith']);
        return context.where("name", "LIKE", "%");
      }
    } else {
      return context.where("name", "LIKE", "%");
    }
  };

  anyRank = function(context) {
    return context.where("rank", ">=", 0);
  };

  properCase = function(string) {
    return string = string.replace(/\w\S*/g, function(txt) {
      var match, proper;
      proper = txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      // console.log "insideProper: " + proper
      if (proper.match(/-([a-z])/) !== null) {
        match = proper.match(/-([a-z])/);
        proper = proper.substring(0, match.index + 1) + proper.charAt(match.index + 1).toUpperCase() + proper.substring(match.index + 2);
      }
      // console.log "MatchLoop: " + proper
      return proper;
    });
  };

  isUndefined = function(element, index, array) {
    return element === undefined;
  };

  module.exports.isUndefined = isUndefined;

  module.exports.limitQuery = limitQuery;

  module.exports.fast = fastSimpleQuery;

  module.exports.frequencyQuery = frequencyQuery;

  module.exports.raceQuery = raceQuery;

  module.exports.yearQuery = yearQuery;

  module.exports.genderQuery = genderQuery;

  module.exports.rankQuery = rankQuery;

  module.exports.startsWithQuery = startsWithQuery;

  module.exports.sanitizeGender = sanitizeGender;

  module.exports.sanitizeYear = sanitizeYear;

  module.exports.properCase = properCase;

  isNumber = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

}).call(this);
